import React from "react";
import { motion } from "framer-motion";

const LudoBoard = ({ team, playerId, onPawnClick, isGameStarted }) => {
  if (!team) return null;

  const colors = {
    red: "#ef4444",
    blue: "#3b82f6",
    green: "#10b981",
    yellow: "#fbbf24",
  };

  // CLASSIC LUDO BOARD - 15x15 GRID STRUCTURE
  // Based on standard Ludo board geometry
  
  const generateClassicLudoBoard = () => {
    const grid = Array(15).fill(null).map(() => 
      Array(15).fill(null).map(() => ({ 
        type: "empty", 
        color: null, 
        pathIndex: -1 
      }))
    );

    // TRACK PATH - 52 cells clockwise starting from RED's start
    const pathCells = [];
    
    // RED SECTION (Starting position for red at bottom of left vertical column)
    // Path goes UP on left column
    pathCells.push({ row: 6, col: 0, color: "red", type: "start" }); // Red start (0)
    for (let i = 1; i < 6; i++) {
      pathCells.push({ row: 6 - i, col: 0, color: null, type: "path" });
    }
    
    // Turn right at top-left corner
    pathCells.push({ row: 0, col: 1, color: null, type: "path" });
    pathCells.push({ row: 0, col: 2, color: null, type: "path" });
    pathCells.push({ row: 0, col: 3, color: null, type: "path" });
    pathCells.push({ row: 0, col: 4, color: null, type: "path" });
    pathCells.push({ row: 0, col: 5, color: null, type: "path" });
    pathCells.push({ row: 0, col: 6, color: null, type: "safe" }); // Safe zone (11)
    
    // GREEN SECTION (Start position at top of middle column)
    pathCells.push({ row: 1, col: 6, color: null, type: "path" });
    pathCells.push({ row: 2, col: 6, color: "green", type: "start" }); // Green start (13)
    for (let i = 1; i < 5; i++) {
      pathCells.push({ row: 2 + i, col: 6, color: null, type: "path" });
    }
    
    // Continue right on top horizontal row
    for (let i = 1; i < 6; i++) {
      pathCells.push({ row: 6, col: 6 + i, color: null, type: "path" });
    }
    pathCells.push({ row: 6, col: 12, color: null, type: "path" });
    pathCells.push({ row: 6, col: 13, color: null, type: "path" });
    pathCells.push({ row: 6, col: 14, color: null, type: "safe" }); // Safe zone (24)
    
    // Turn down at top-right corner
    pathCells.push({ row: 7, col: 14, color: null, type: "path" });
    pathCells.push({ row: 8, col: 14, color: "yellow", type: "start" }); // Yellow start (26)
    for (let i = 1; i < 5; i++) {
      pathCells.push({ row: 8 + i, col: 14, color: null, type: "path" });
    }
    
    // Continue down on right vertical column
    for (let i = 1; i < 2; i++) {
      pathCells.push({ row: 12 + i, col: 14, color: null, type: "path" });
    }
    pathCells.push({ row: 14, col: 14, color: null, type: "path" });
    
    // Turn left at bottom-right corner
    pathCells.push({ row: 14, col: 13, color: null, type: "path" });
    pathCells.push({ row: 14, col: 12, color: null, type: "path" });
    pathCells.push({ row: 14, col: 11, color: null, type: "path" });
    pathCells.push({ row: 14, col: 10, color: null, type: "path" });
    pathCells.push({ row: 14, col: 9, color: null, type: "path" });
    pathCells.push({ row: 14, col: 8, color: null, type: "safe" }); // Safe zone (37)
    
    // BLUE SECTION (Start at bottom middle)
    pathCells.push({ row: 14, col: 7, color: null, type: "path" });
    pathCells.push({ row: 13, col: 8, color: "blue", type: "start" }); // Blue start (39)
    for (let i = 1; i < 5; i++) {
      pathCells.push({ row: 13 - i, col: 8, color: null, type: "path" });
    }
    
    // Continue left on bottom row
    for (let i = 1; i < 6; i++) {
      pathCells.push({ row: 8, col: 8 - i, color: null, type: "path" });
    }
    pathCells.push({ row: 8, col: 2, color: null, type: "path" });
    pathCells.push({ row: 8, col: 1, color: null, type: "path" });
    pathCells.push({ row: 8, col: 0, color: null, type: "safe" }); // Safe zone (50)
    
    // Complete the loop back to red
    pathCells.push({ row: 7, col: 0, color: null, type: "path" }); // (51)

    // Populate grid with path cells
    pathCells.forEach((cell, index) => {
      grid[cell.row][cell.col] = {
        type: cell.type,
        color: cell.color,
        pathIndex: index
      };
    });

    // HOME STRETCH LANES (5 cells leading to center for each color)
    // RED home stretch (going right from col 1 to 6 on row 7)
    for (let col = 1; col <= 5; col++) {
      grid[7][col] = { type: "home-stretch", color: "red", pathIndex: -1 };
    }
    
    // GREEN home stretch (going down from row 1 to 6 on col 7)
    for (let row = 1; row <= 5; row++) {
      grid[row][7] = { type: "home-stretch", color: "green", pathIndex: -1 };
    }
    
    // YELLOW home stretch (going left from col 13 to 9 on row 7)
    for (let col = 13; col >= 9; col--) {
      grid[7][col] = { type: "home-stretch", color: "yellow", pathIndex: -1 };
    }
    
    // BLUE home stretch (going up from row 13 to 9 on col 7)
    for (let row = 13; row >= 9; row--) {
      grid[row][7] = { type: "home-stretch", color: "blue", pathIndex: -1 };
    }

    // CENTER FINISH AREA (3x3 cross/star)
    for (let row = 6; row <= 8; row++) {
      for (let col = 6; col <= 8; col++) {
        grid[row][col] = { type: "center", color: null, pathIndex: -1 };
      }
    }

    return { grid, pathCells };
  };

  const { grid, pathCells } = generateClassicLudoBoard();

  // Render pawn on track using path index
  const renderTrackPawn = (player, pawnIndex, position) => {
    if (position === 0) return null;
    if (!player) return null;

    // Calculate grid position based on player color and position
    const getGridPosition = (pos, playerColor) => {
      const startOffsets = {
        red: 0,
        green: 13,
        yellow: 26,
        blue: 39
      };

      const offset = startOffsets[playerColor] || 0;
      const cellIndex = (pos - 1 + offset) % pathCells.length;
      
      if (cellIndex >= 0 && cellIndex < pathCells.length) {
        const cell = pathCells[cellIndex];
        return { row: cell.row, col: cell.col };
      }
      
      return null;
    };

    const gridPos = getGridPosition(position, player.color);
    if (!gridPos) return null;

    const cellSize = 100 / 15;
    const left = (gridPos.col + 0.5) * cellSize;
    const top = (gridPos.row + 0.5) * cellSize;

    const isMyPawn = player.id === playerId;
    const canMove = isGameStarted && team.currentTurn === player.id && isMyPawn;

    return (
      <motion.div
        key={`${player.id}-${pawnIndex}`}
        onClick={() => isMyPawn && onPawnClick ? onPawnClick(pawnIndex) : null}
        style={{
          position: "absolute",
          left: `${left}%`,
          top: `${top}%`,
          width: "5%",
          height: "5%",
          background: `linear-gradient(135deg, ${colors[player.color]}, ${colors[player.color]}dd)`,
          borderRadius: "50%",
          border: isMyPawn ? "3px solid white" : "2px solid rgba(255,255,255,0.6)",
          cursor: canMove ? "pointer" : "default",
          transform: "translate(-50%, -50%)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: "white",
          fontWeight: "bold",
          fontSize: "0.7rem",
          boxShadow: "0 4px 12px rgba(0,0,0,0.5)",
          zIndex: 20 + position,
          opacity: isMyPawn ? 1 : 0.85,
        }}
        whileHover={canMove ? { scale: 1.3 } : {}}
        whileTap={canMove ? { scale: 0.9 } : {}}
        animate={canMove ? { scale: [1, 1.1, 1] } : {}}
        transition={{ duration: 0.6, repeat: Infinity }}
      >
        {pawnIndex + 1}
      </motion.div>
    );
  };

  // Render home area with 4 pawn slots
  const renderHomeArea = (color) => {
    const playersWithColor = team.players.filter((p) => p.color === color);
    const hasPlayers = playersWithColor.length > 0;

    // Home area positions in grid (6x6 areas in corners)
    const homeAreas = {
      red: { startRow: 0, startCol: 0 },
      green: { startRow: 0, startCol: 9 },
      yellow: { startRow: 9, startCol: 9 },
      blue: { startRow: 9, startCol: 0 }
    };

    const home = homeAreas[color];
    const cellSize = 100 / 15;

    // 4 pawn slots in 2x2 arrangement within the 6x6 home
    const pawnSlots = [
      { row: home.startRow + 2, col: home.startCol + 2 },
      { row: home.startRow + 2, col: home.startCol + 4 },
      { row: home.startRow + 4, col: home.startCol + 2 },
      { row: home.startRow + 4, col: home.startCol + 4 }
    ];

    return (
      <>
        {/* Home area background */}
        <div
          style={{
            position: "absolute",
            left: `${home.startCol * cellSize}%`,
            top: `${home.startRow * cellSize}%`,
            width: `${6 * cellSize}%`,
            height: `${6 * cellSize}%`,
            background: `linear-gradient(135deg, ${colors[color]}30, ${colors[color]}10)`,
            border: `3px solid ${colors[color]}`,
            borderRadius: "8px",
            boxShadow: `inset 0 0 20px ${colors[color]}20`,
          }}
        />

        {/* Pawn slots and pawns */}
        {pawnSlots.map((slot, slotIndex) => {
          const left = (slot.col + 0.5) * cellSize;
          const top = (slot.row + 0.5) * cellSize;

          // Find pawns at home (position 0) for this slot
          const pawnsAtHome = [];
          playersWithColor.forEach(player => {
            player.pawns.forEach((pos, pawnIdx) => {
              if (pos === 0) {
                pawnsAtHome.push({ player, pawnIdx });
              }
            });
          });

          const pawnData = pawnsAtHome[slotIndex];

          return (
            <div
              key={`${color}-slot-${slotIndex}`}
              style={{
                position: "absolute",
                left: `${left}%`,
                top: `${top}%`,
                width: "5%",
                height: "5%",
                transform: "translate(-50%, -50%)",
              }}
            >
              {pawnData ? (
                <motion.div
                  onClick={() =>
                    pawnData.player.id === playerId && onPawnClick
                      ? onPawnClick(pawnData.pawnIdx)
                      : null
                  }
                  style={{
                    width: "100%",
                    height: "100%",
                    background: `linear-gradient(135deg, ${colors[color]}, ${colors[color]}dd)`,
                    borderRadius: "50%",
                    border: pawnData.player.id === playerId ? "3px solid white" : "2px solid rgba(255,255,255,0.6)",
                    cursor: isGameStarted && team.currentTurn === pawnData.player.id ? "pointer" : "default",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "white",
                    fontWeight: "bold",
                    fontSize: "0.7rem",
                    boxShadow: "0 4px 12px rgba(0,0,0,0.5)",
                  }}
                  whileHover={isGameStarted && team.currentTurn === pawnData.player.id ? { scale: 1.2 } : {}}
                  animate={isGameStarted && team.currentTurn === pawnData.player.id ? { y: [0, -4, 0] } : {}}
                  transition={{ duration: 0.6, repeat: Infinity }}
                >
                  {pawnData.pawnIdx + 1}
                </motion.div>
              ) : (
                <div
                  style={{
                    width: "100%",
                    height: "100%",
                    background: `${colors[color]}20`,
                    borderRadius: "50%",
                    border: `2px dashed ${colors[color]}60`,
                  }}
                />
              )}
            </div>
          );
        })}
      </>
    );
  };

  // Render the 15x15 grid board
  const renderBoard = () => {
    const cellSize = 100 / 15;

    return (
      <>
        {/* Render grid cells */}
        {grid.map((row, rowIndex) =>
          row.map((cell, colIndex) => {
            const left = colIndex * cellSize;
            const top = rowIndex * cellSize;

            let bgColor = "#fafafa";
            let borderColor = "#e0e0e0";

            if (cell.type === "path" || cell.type === "start") {
              bgColor = cell.color ? `${colors[cell.color]}20` : "#fff";
              borderColor = cell.color ? colors[cell.color] : "#ccc";
            } else if (cell.type === "safe") {
              bgColor = "#fef3c7";
              borderColor = "#f59e0b";
            } else if (cell.type === "home-stretch") {
              bgColor = `${colors[cell.color]}40`;
              borderColor = colors[cell.color];
            } else if (cell.type === "center") {
              bgColor = "linear-gradient(135deg, #fbbf24, #f59e0b)";
              borderColor = "#dc2626";
            }

            return (
              <div
                key={`${rowIndex}-${colIndex}`}
                style={{
                  position: "absolute",
                  left: `${left}%`,
                  top: `${top}%`,
                  width: `${cellSize}%`,
                  height: `${cellSize}%`,
                  background: bgColor,
                  border: `1px solid ${borderColor}`,
                  boxSizing: "border-box",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: "0.5rem",
                  color: "#666",
                  fontWeight: "bold",
                }}
              >
                {cell.type === "center" && "★"}
                {cell.type === "start" && "S"}
                {cell.pathIndex >= 0 && <span style={{ fontSize: "0.45rem" }}>{cell.pathIndex}</span>}
              </div>
            );
          })
        )}
      </>
    );
  };

  return (
    <motion.div
      style={{
        width: "100%",
        maxWidth: "650px",
        margin: "0 auto",
        aspectRatio: "1",
        position: "relative",
        background: "linear-gradient(135deg, #1f2937, #111827)",
        borderRadius: "20px",
        padding: "12px",
        boxShadow: "0 20px 60px rgba(0,0,0,0.6)",
      }}
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
    >
      <div
        style={{
          width: "100%",
          height: "100%",
          position: "relative",
          background: "#f5f5f5",
          borderRadius: "16px",
          overflow: "hidden",
        }}
      >
        {/* Render the board grid */}
        {renderBoard()}

        {/* Render home areas */}
        {renderHomeArea("red")}
        {renderHomeArea("green")}
        {renderHomeArea("yellow")}
        {renderHomeArea("blue")}

        {/* Render pawns on track */}
        {team.players.map((player) =>
          player.pawns.map((position, index) =>
            renderTrackPawn(player, index, position)
          )
        )}
      </div>
    </motion.div>
  );
};

export default LudoBoard;

  const CellType = {
    HOME: "HOME",
    PATH: "PATH",
    START: "START",
    SAFE_ZONE: "SAFE_ZONE",
    HOME_COLUMN: "HOME_COLUMN",
    CENTER: "CENTER",
    EMPTY: "EMPTY",
  };

  // Generate 15x15 Ludo board grid
  const generateBoard = () => {
    const grid = Array(15)
      .fill(null)
      .map(() => Array(15).fill({ type: CellType.EMPTY, color: null }));

    // Path positions in clockwise order starting from Red's start
    // Red path: starts at [6, 1]
    // Green path: starts at [1, 8]
    // Yellow path: starts at [8, 13]
    // Blue path: starts at [13, 6]

    let pathIndex = 0;
    const pathCells = [];

    // RED's section - left side going UP (cells 0-5)
    for (let i = 0; i < 6; i++) {
      grid[6 - i][1] = {
        type: i === 0 ? CellType.START : CellType.PATH,
        color: "red",
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 6 - i, col: 1 });
    }

    // Turn to top horizontal - going RIGHT (cells 6-7)
    grid[0][2] = { type: CellType.PATH, color: null, pathIndex: pathIndex++ };
    pathCells.push({ row: 0, col: 2 });
    grid[0][3] = { type: CellType.PATH, color: null, pathIndex: pathIndex++ };
    pathCells.push({ row: 0, col: 3 });
    grid[0][4] = { type: CellType.PATH, color: null, pathIndex: pathIndex++ };
    pathCells.push({ row: 0, col: 4 });
    grid[0][5] = { type: CellType.PATH, color: null, pathIndex: pathIndex++ };
    pathCells.push({ row: 0, col: 5 });
    grid[0][6] = {
      type: CellType.SAFE_ZONE,
      color: null,
      pathIndex: pathIndex++,
    };
    pathCells.push({ row: 0, col: 6 });

    // GREEN's section - top going RIGHT (cells 13-17)
    for (let i = 0; i < 5; i++) {
      grid[1][6 + i] = {
        type: i === 2 ? CellType.START : CellType.PATH,
        color: "green",
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 1, col: 6 + i });
    }

    // Turn to right vertical - going DOWN (cells 18-22)
    for (let i = 0; i < 5; i++) {
      grid[2 + i][13] = {
        type: CellType.PATH,
        color: null,
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 2 + i, col: 13 });
    }
    grid[7][13] = {
      type: CellType.SAFE_ZONE,
      color: null,
      pathIndex: pathIndex++,
    };
    pathCells.push({ row: 7, col: 13 });

    // YELLOW's section - right side going DOWN (cells 23-27)
    for (let i = 0; i < 5; i++) {
      grid[8 + i][13] = {
        type: i === 2 ? CellType.START : CellType.PATH,
        color: "yellow",
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 8 + i, col: 13 });
    }

    // Turn to bottom horizontal - going LEFT (cells 28-32)
    for (let i = 0; i < 5; i++) {
      grid[14][12 - i] = {
        type: CellType.PATH,
        color: null,
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 14, col: 12 - i });
    }
    grid[14][7] = {
      type: CellType.SAFE_ZONE,
      color: null,
      pathIndex: pathIndex++,
    };
    pathCells.push({ row: 14, col: 7 });

    // BLUE's section - bottom going LEFT (cells 33-37)
    for (let i = 0; i < 5; i++) {
      grid[13][7 - i] = {
        type: i === 2 ? CellType.START : CellType.PATH,
        color: "blue",
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 13, col: 7 - i });
    }

    // Turn to left vertical - going UP (cells 38-42)
    for (let i = 0; i < 5; i++) {
      grid[12 - i][1] = {
        type: CellType.PATH,
        color: null,
        pathIndex: pathIndex++,
      };
      pathCells.push({ row: 12 - i, col: 1 });
    }
    grid[7][1] = {
      type: CellType.SAFE_ZONE,
      color: null,
      pathIndex: pathIndex++,
    };
    pathCells.push({ row: 7, col: 1 });

    // Home columns (colored paths leading to center)
    // Red home column (going right from [7,2] to [7,6])
    for (let i = 2; i <= 6; i++) {
      grid[7][i] = { type: CellType.HOME_COLUMN, color: "red", pathIndex: -1 };
    }
    // Green home column (going down from [2,7] to [6,7])
    for (let i = 2; i <= 6; i++) {
      grid[i][7] = {
        type: CellType.HOME_COLUMN,
        color: "green",
        pathIndex: -1,
      };
    }
    // Yellow home column (going left from [7,12] to [7,8])
    for (let i = 12; i >= 8; i--) {
      grid[7][i] = {
        type: CellType.HOME_COLUMN,
        color: "yellow",
        pathIndex: -1,
      };
    }
    // Blue home column (going up from [12,7] to [8,7])
    for (let i = 12; i >= 8; i--) {
      grid[i][7] = { type: CellType.HOME_COLUMN, color: "blue", pathIndex: -1 };
    }

    // Center finishing area
    grid[7][7] = { type: CellType.CENTER, color: null, pathIndex: -1 };

    return { grid, pathCells };
  };

  const { grid, pathCells } = generateBoard();

  // Ludo board has 52 positions on the outer track
  const renderHomeArea = (color, position) => {
    // Get all players with this color
    const playersWithColor = team.players.filter((p) => p.color === color);
    const hasPlayers = playersWithColor.length > 0;

    const homePositions = [
      { top: "30%", left: "30%" },
      { top: "30%", left: "70%" },
      { top: "70%", left: "30%" },
      { top: "70%", left: "70%" },
    ];

    const containerPositions = {
      red: { top: "3%", left: "3%" },
      green: { top: "3%", right: "3%" },
      yellow: { bottom: "3%", right: "3%" },
      blue: { bottom: "3%", left: "3%" },
    };

    return (
      <div
        style={{
          position: "absolute",
          ...containerPositions[color],
          width: "37%",
          height: "37%",
          background: `linear-gradient(135deg, ${colors[color]}50, ${colors[color]}30)`,
          border: `4px solid ${colors[color]}`,
          borderRadius: "8px",
          boxShadow: `inset 0 0 20px ${colors[color]}30`,
          opacity: hasPlayers ? 1 : 0.5,
        }}
      >
        {/* Home circle indicator */}
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "80%",
            height: "80%",
            border: `3px dashed ${colors[color]}80`,
            borderRadius: "50%",
          }}
        />

        {/* Player name label - show all players with this color */}
        <div
          style={{
            position: "absolute",
            top: "8px",
            left: "50%",
            transform: "translateX(-50%)",
            background: colors[color],
            color: "white",
            padding: "4px 12px",
            borderRadius: "12px",
            fontSize: "0.75rem",
            fontWeight: "bold",
            boxShadow: "0 2px 4px rgba(0,0,0,0.2)",
            maxWidth: "90%",
            textAlign: "center",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
          }}
        >
          {hasPlayers
            ? playersWithColor.map((p) => p.name).join(", ")
            : "Waiting..."}
        </div>

        {/* Home pawns area - show pawns from all players with this color */}
        <div style={{ position: "relative", width: "100%", height: "100%" }}>
          {hasPlayers
            ? playersWithColor.flatMap((player, playerIndex) =>
                player.pawns.map((pawnPos, pawnIndex) => {
                  if (pawnPos === 0) {
                    // Calculate which home position to use (cycle through available positions)
                    const totalPawnsAtHome = playersWithColor
                      .slice(0, playerIndex)
                      .reduce(
                        (count, p) =>
                          count + p.pawns.filter((pos) => pos === 0).length,
                        0
                      );
                    const positionIndex =
                      (totalPawnsAtHome + pawnIndex) % homePositions.length;

                    return (
                      <motion.div
                        key={`${player.id}-${pawnIndex}`}
                        onClick={() =>
                          player.id === playerId && onPawnClick
                            ? onPawnClick(pawnIndex)
                            : null
                        }
                        style={{
                          position: "absolute",
                          ...homePositions[positionIndex],
                          width: "22%",
                          height: "22%",
                          background: `linear-gradient(135deg, ${colors[color]}, ${colors[color]}dd)`,
                          borderRadius: "50%",
                          border:
                            player.id === playerId
                              ? "4px solid white"
                              : "3px solid rgba(255,255,255,0.6)",
                          cursor:
                            isGameStarted && team.currentTurn === player.id
                              ? "pointer"
                              : "default",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          color: "white",
                          fontWeight: "bold",
                          fontSize: "0.8rem",
                          boxShadow: "0 4px 12px rgba(0,0,0,0.4)",
                          transform: "translate(-50%, -50%)",
                          opacity: player.id === playerId ? 1 : 0.85,
                        }}
                        whileHover={
                          isGameStarted && team.currentTurn === player.id
                            ? { scale: 1.25, rotate: 360 }
                            : {}
                        }
                        whileTap={
                          isGameStarted && team.currentTurn === player.id
                            ? { scale: 0.85 }
                            : {}
                        }
                        animate={
                          isGameStarted && team.currentTurn === player.id
                            ? { y: [0, -5, 0] }
                            : {}
                        }
                        transition={{
                          duration: 0.6,
                          repeat: Infinity,
                          repeatDelay: 1,
                        }}
                      >
                        {pawnIndex + 1}
                      </motion.div>
                    );
                  }
                  return null;
                })
              )
            : // Show empty pawn slots for players who haven't joined
              homePositions.map((pos, index) => (
                <div
                  key={index}
                  style={{
                    position: "absolute",
                    ...pos,
                    width: "22%",
                    height: "22%",
                    background: `${colors[color]}40`,
                    borderRadius: "50%",
                    border: `3px dashed ${colors[color]}80`,
                    transform: "translate(-50%, -50%)",
                  }}
                />
              ))}
        </div>
      </div>
    );
  };

  const renderTrackPawn = (player, pawnIndex, position) => {
    if (position === 0) return null;
    if (!player) return null;

    // Use grid-based positioning
    const getTrackPosition = (pos, playerColor) => {
      // Map player position to path cell index
      const colorStartPositions = {
        red: 0,
        green: 13,
        yellow: 25,
        blue: 38,
      };

      const startPos = colorStartPositions[playerColor] || 0;
      const cellIndex = (pos - 1 + startPos) % pathCells.length;

      if (cellIndex < pathCells.length) {
        const cell = pathCells[cellIndex];
        const left = ((cell.col + 0.5) / 15) * 100;
        const top = ((cell.row + 0.5) / 15) * 100;
        return { left: `${left}%`, top: `${top}%` };
      }

      return { left: "50%", top: "50%" };
    };

    if (position > 0 && position <= 52) {
      const pos = getTrackPosition(position, player.color);
      const isMyPawn = player.id === playerId;
      const canMove =
        isGameStarted && team.currentTurn === player.id && isMyPawn;

      return (
        <motion.div
          key={`${player.id}-${pawnIndex}`}
          onClick={() =>
            isMyPawn && onPawnClick ? onPawnClick(pawnIndex) : null
          }
          style={{
            position: "absolute",
            ...pos,
            width: "5%",
            height: "5%",
            background: `linear-gradient(135deg, ${colors[player.color]}, ${
              colors[player.color]
            }dd)`,
            borderRadius: "50%",
            border: isMyPawn
              ? "3px solid white"
              : "2px solid rgba(255,255,255,0.6)",
            cursor: canMove ? "pointer" : "default",
            transform: "translate(-50%, -50%)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "white",
            fontWeight: "bold",
            fontSize: "0.75rem",
            boxShadow: "0 4px 12px rgba(0,0,0,0.5)",
            zIndex: 10 + position,
            opacity: isMyPawn ? 1 : 0.85,
          }}
          whileHover={canMove ? { scale: 1.4, rotate: 360 } : {}}
          whileTap={canMove ? { scale: 0.85 } : {}}
          initial={{ scale: 0, rotate: -180 }}
          animate={
            canMove
              ? { y: [0, -8, 0], scale: [1, 1.15, 1], rotate: 0 }
              : { scale: [1, 1.05, 1], rotate: 0 }
          }
          transition={{
            duration: canMove ? 0.5 : 1,
            repeat: Infinity,
            repeatDelay: canMove ? 0.5 : 2,
          }}
        >
          {pawnIndex + 1}
        </motion.div>
      );
    }

    return null;
  };

  const renderTrack = () => {
    const cellWidth = 100 / 15;
    const cellHeight = 100 / 15;

    return (
      <>
        {/* Render all 15x15 grid cells */}
        {grid.map((row, rowIndex) =>
          row.map((cell, colIndex) => {
            if (cell.type === CellType.EMPTY) return null;

            const left = colIndex * cellWidth;
            const top = rowIndex * cellHeight;

            let bgColor = "#fff";
            let borderColor = "#e5e7eb";

            if (cell.type === CellType.START || cell.type === CellType.PATH) {
              bgColor = cell.color ? `${colors[cell.color]}30` : "#f9fafb";
              borderColor = cell.color ? colors[cell.color] : "#d1d5db";
            } else if (cell.type === CellType.SAFE_ZONE) {
              bgColor = "#fef3c7";
              borderColor = "#f59e0b";
            } else if (cell.type === CellType.HOME_COLUMN) {
              bgColor = `${colors[cell.color]}50`;
              borderColor = colors[cell.color];
            } else if (cell.type === CellType.CENTER) {
              bgColor = "linear-gradient(135deg, #fbbf24, #f59e0b, #dc2626)";
              borderColor = "#dc2626";
            }

            return (
              <div
                key={`cell-${rowIndex}-${colIndex}`}
                style={{
                  position: "absolute",
                  left: `${left}%`,
                  top: `${top}%`,
                  width: `${cellWidth}%`,
                  height: `${cellHeight}%`,
                  background: bgColor,
                  border: `2px solid ${borderColor}`,
                  boxSizing: "border-box",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: "0.5rem",
                  fontWeight: "bold",
                  color: "#666",
                }}
              >
                {cell.type === CellType.CENTER && "⭐"}
                {cell.type === CellType.START && "H"}
                {cell.pathIndex >= 0 && cell.pathIndex}
              </div>
            );
          })
        )}
      </>
    );
  };

  return (
    <motion.div
      style={{
        width: "100%",
        maxWidth: "650px",
        margin: "0 auto",
        aspectRatio: "1",
        position: "relative",
        background: "linear-gradient(135deg, #1f2937, #111827)",
        borderRadius: "20px",
        padding: "12px",
        boxShadow: "0 20px 60px rgba(0,0,0,0.6), 0 0 0 8px #374151",
      }}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
    >
      {/* Board container */}
      <div
        style={{
          width: "100%",
          height: "100%",
          position: "relative",
          background: "linear-gradient(135deg, #fefefe, #f5f5f5)",
          borderRadius: "16px",
          overflow: "hidden",
          boxShadow: "inset 0 2px 10px rgba(0,0,0,0.1)",
        }}
      >
        {/* Draw the 15x15 grid-based track */}
        {renderTrack()}

        {/* Render home areas for all players */}
        {renderHomeArea("red", "top-left")}
        {renderHomeArea("green", "top-right")}
        {renderHomeArea("yellow", "bottom-right")}
        {renderHomeArea("blue", "bottom-left")}

        {/* Render pawns on the track */}
        {team.players.map((player) =>
          player.pawns.map((position, index) =>
            renderTrackPawn(player, index, position)
          )
        )}
      </div>
    </motion.div>
  );
};

export default LudoBoard;
